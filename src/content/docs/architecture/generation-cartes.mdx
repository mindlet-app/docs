---
title: G√©n√©ration de cartes
description: Architecture agentic du Card Generator Graph pour la cr√©ation de cartes d'apprentissage
sidebar:
  order: 7
---

import { Aside, Badge, Card, CardGrid, Steps, TabItem, Tabs, FileTree } from '@astrojs/starlight/components';
import MermaidDownload from '../../../components/MermaidDownload.astro';

# üé¥ G√©n√©ration de cartes

<Badge text="Agentic" variant="success" />
<Badge text="Mistral AI" variant="note" />
<Badge text="Multi-types" variant="caution" />

## Introduction

Le **Card Generator Graph** est le composant le plus **complexe et innovant** du syst√®me. Contrairement √† un simple appel LLM qui g√©n√®re des cartes en une seule passe, nous utilisons une architecture **agentic** ‚Äî c'est-√†-dire un syst√®me o√π plusieurs agents IA collaborent et s'auto-corrigent.

<Aside type="tip" title="Qu'est-ce qu'une architecture agentic ?">
  Une architecture **agentic** est un design o√π plusieurs agents sp√©cialis√©s travaillent ensemble vers un objectif commun. Chaque agent a une responsabilit√© pr√©cise (planifier, g√©n√©rer, critiquer, am√©liorer...) et ils communiquent via un √©tat partag√©. L'avantage ? La qualit√© finale est bien sup√©rieure √† une g√©n√©ration en une seule passe car les agents peuvent d√©tecter et corriger les erreurs.
</Aside>

## Vue d'ensemble

Le syst√®me utilise **5 agents sp√©cialis√©s** qui collaborent en boucle jusqu'√† atteindre la qualit√© souhait√©e :

| Agent | R√¥le | Analogie |
|-------|------|----------|
| **Planner** üìã | Analyse le contenu et cr√©e une strat√©gie de g√©n√©ration | Le chef de projet qui fait le plan |
| **Generator** ‚úèÔ∏è | Cr√©e les cartes selon le plan √©tabli | Le r√©dacteur qui √©crit |
| **Critic** üîç | √âvalue chaque carte et d√©tecte les probl√®mes | Le relecteur qui pointe les erreurs |
| **Refiner** üîß | Am√©liore les cartes selon le feedback du Critic | Le correcteur qui am√©liore |
| **Finalizer** ‚úÖ | Valide et g√©n√®re les m√©tadonn√©es finales | Le responsable qualit√© qui approuve |

### Le flux de collaboration

<MermaidDownload title="Flux de collaboration des agents">
```mermaid
flowchart LR
    A["üìã Planner"] --> B["‚úèÔ∏è Generator"]
    B --> C["üîç Critic"]
    C -->|"Score < 7.5"| D["üîß Refiner"]
    D -->|"√âessayer"| B
    C -->|"Score ‚â• 7.5"| E["‚úÖ Finalizer"]
    D -->|"Max tentatives"| E
    
    style A fill:#e3f2fd,stroke:#1976d2
    style B fill:#fff3e0,stroke:#f57c00
    style C fill:#fce4ec,stroke:#c2185b
    style D fill:#e8f5e9,stroke:#388e3c
    style E fill:#e0f7fa,stroke:#0097a7
```
</MermaidDownload>

## Diagramme du Card Generator Graph

Ce diagramme montre les **boucles de feedback** qui sont la cl√© de la qualit√©. Notez comment le `critic` peut renvoyer vers le `generator` (pour r√©g√©n√©rer) ou vers le `refiner` (pour am√©liorer) :

<MermaidDownload title="Card Generator Graph">
```mermaid
graph TD;
    __start__([__start__]):::first
    validate_inputs(validate_inputs)
    select_chunks(select_chunks)
    planner(planner)
    generator(generator)
    critic(critic)
    refiner(refiner)
    finalizer(finalizer)
    __end__([__end__]):::last
    
    __start__ --> validate_inputs;
    validate_inputs -. end .-> __end__;
    validate_inputs -.-> select_chunks;
    select_chunks --> planner;
    planner --> generator;
    generator --> critic;
    critic -.-> finalizer;
    critic -.-> generator;
    critic -.-> refiner;
    refiner -.-> finalizer;
    refiner -.-> generator;
    finalizer --> __end__;
    
    classDef default fill:#f2f0ff,line-height:1.2
    classDef first fill-opacity:0
    classDef last fill:#bfb6fc
```
</MermaidDownload>

<Aside type="note" title="Les boucles de feedback">
  Les lignes pointill√©es depuis `critic` vers `generator` et `refiner` repr√©sentent les **boucles de feedback**. Si une carte n'atteint pas le score minimum de qualit√© (7.5/10), elle est soit am√©lior√©e (refiner), soit r√©g√©n√©r√©e (generator). Ce processus peut se r√©p√©ter jusqu'√† 2 fois par carte.
</Aside>

## Architecture agentic d√©taill√©e

Le diagramme ci-dessous montre l'architecture interne avec les diff√©rents outils (tools) que chaque agent peut utiliser :

<MermaidDownload title="Architecture agentic d√©taill√©e">
```mermaid
flowchart TB
    subgraph AGENT["ü§ñ CARD GENERATION AGENT<br/>(mistral-medium-latest)"]
        direction TB
        
        PLANNER["üéØ PLANNER<br/>Analyse le contenu<br/>Planifie la strat√©gie"]
        
        subgraph LOOP["üîÑ Boucle d'am√©lioration"]
            direction LR
            GENERATOR["‚ö° GENERATOR<br/>Cr√©e les cartes"]
            CRITIC["üîç CRITIC<br/>√âvalue qualit√©<br/>& diversit√©"]
            REFINER["‚ú® REFINER<br/>Am√©liore<br/>les cartes"]
        end
        
        COLLECTION["üìö CARD COLLECTION"]
        FINALIZER["üìã FINALIZER<br/>G√©n√®re metadata<br/>V√©rifie compl√©tude"]
    end
    
    PLANNER --> GENERATOR
    GENERATOR --> CRITIC
    CRITIC -->|"Besoin d'am√©lioration"| REFINER
    REFINER -->|"Re-g√©n√©ration"| GENERATOR
    CRITIC -->|"Cartes valid√©es"| COLLECTION
    REFINER -->|"Cartes am√©lior√©es"| COLLECTION
    COLLECTION --> FINALIZER
    
    style AGENT fill:#f5f5f5,stroke:#333,stroke-width:2px
    style PLANNER fill:#e3f2fd,stroke:#1976d2
    style GENERATOR fill:#fff3e0,stroke:#f57c00
    style CRITIC fill:#fce4ec,stroke:#c2185b
    style REFINER fill:#e8f5e9,stroke:#388e3c
    style COLLECTION fill:#f3e5f5,stroke:#7b1fa2
    style FINALIZER fill:#e0f7fa,stroke:#0097a7
    style LOOP fill:#fafafa,stroke:#9e9e9e,stroke-dasharray: 5 5
```
</MermaidDownload>

---

## Types de cartes support√©s

Le syst√®me peut g√©n√©rer **9 types de cartes** diff√©rents, chacun adapt√© √† un style d'apprentissage particulier. Le **Planner** d√©cide de la r√©partition optimale en fonction du contenu.

<Aside type="tip" title="Comment le syst√®me choisit-il les types ?">
  Le Planner analyse le contenu des chunks pour d√©terminer quels types sont pertinents :
  - Contenu factuel ‚Üí **Flashcards**, **Vrai/Faux**
  - Contenu avec options ‚Üí **QCM** avec distracteurs
  - Contenu avec s√©quences ‚Üí **Ranking**, **Drag & Drop**
  - Contenu num√©rique ‚Üí **Slider**
  - Contenu g√©ographique ‚Üí **GeoGuess**
</Aside>

```python
class CardType(str, Enum):
    """Types de cartes disponibles pour la g√©n√©ration.
    
    Chaque type a un format de sortie sp√©cifique et une difficult√©
    de g√©n√©ration diff√©rente (refl√©t√©e dans le nombre de tokens).
    """
    FLASHCARD = "flashcard"          # Question/R√©ponse classique
    MCQ = "mcq"                      # QCM avec distracteurs intelligents
    FREE_TEXT = "free_text"          # R√©ponse libre √©valu√©e par mots-cl√©s
    TRUE_OR_FALSE = "true_or_false"  # Affirmation √† valider
    MATCH_PAIR = "match_pair"        # Correspondance terme ‚Üî d√©finition
    SLIDER = "slider"                # Estimation num√©rique
    DRAG_AND_DROP = "drag_and_drop"  # Placement dans des cat√©gories
    RANKING = "ranking"              # Classement par ordre
    GEO_GUESS = "geo_guess"          # Localisation sur une carte
```

### Pr√©sentation des types de cartes

<CardGrid>
  <Card title="Flashcard" icon="document">
    **Question/r√©ponse classique** pour la m√©morisation rapide. Le format le plus simple et le plus efficace pour le rappel actif.
  </Card>
  <Card title="QCM" icon="list-format">
    **Question √† choix multiples** avec distracteurs intelligents. Le syst√®me g√©n√®re des options plausibles mais incorrectes pour tester la compr√©hension.
  </Card>
  <Card title="Vrai/Faux" icon="approve-check">
    **Affirmation √† valider** avec explication d√©taill√©e. Id√©al pour corriger les id√©es re√ßues.
  </Card>
  <Card title="Match Pair" icon="puzzle">
    Relier des √©l√©ments correspondants entre eux.
  </Card>
  <Card title="Texte libre" icon="pencil">
    R√©ponse ouverte pour approfondir la compr√©hension.
  </Card>
  <Card title="Classement" icon="list-format">
    Ordonner des √©l√©ments selon un crit√®re donn√©.
  </Card>
</CardGrid>

---

## Workflow de g√©n√©ration

<Steps>
1. **Validation des inputs**
   - V√©rification des chunks embedd√©s
   - Validation des types de cartes demand√©s
   - V√©rification du nombre de cartes souhait√©

2. **S√©lection des chunks**
   - Algorithme K-means pour diversit√©
   - S√©lection des chunks les plus repr√©sentatifs
   - √âquilibrage du contenu

3. **Planification (Planner)**
   - Analyse du contenu des chunks
   - R√©partition des types de cartes
   - Strat√©gie de couverture du sujet

4. **G√©n√©ration (Generator)**
   - Cr√©ation des cartes selon le plan
   - Respect des formats par type
   - G√©n√©ration des distracteurs (QCM)

5. **√âvaluation (Critic)**
   - Score de qualit√© par carte
   - D√©tection des doublons
   - V√©rification de la diversit√©

6. **Raffinement (Refiner)**
   - Am√©lioration des cartes faibles
   - Suppression des doublons
   - Ajustement du niveau de difficult√©

7. **Finalisation**
   - G√©n√©ration des m√©tadonn√©es
   - Calcul des statistiques
   - Validation finale de la collection
</Steps>

---

## Agents du syst√®me

Chaque agent a un **r√¥le pr√©cis** et utilise un **prompt YAML** d√©di√©. Voici comment ils fonctionnent en d√©tail :

### Planner Agent üìã

Le Planner est le **strat√®ge** du syst√®me. Il analyse les chunks et d√©cide :
- Combien de cartes de chaque type g√©n√©rer
- Quels sujets prioriser
- Quelle courbe de difficult√© adopter

```python
class GenerationPlan(BaseModel):
    """Plan de g√©n√©ration cr√©√© par le Planner.
    
    Ce plan guide le Generator pour produire des cartes √©quilibr√©es
    et adapt√©es au contenu source.
    """
    card_distribution: Dict[CardType, int]  # Ex: {FLASHCARD: 5, MCQ: 3}
    focus_topics: List[str]                  # Sujets identifi√©s √† couvrir
    difficulty_curve: List[int]              # [1, 2, 2, 3, 3, 4] = progression
    reasoning: str                           # Explication (pour le debug)
```

<Aside type="note" title="Pourquoi un Planner ?">
  Sans planification, le Generator produirait des cartes de mani√®re al√©atoire. Le Planner assure une **couverture compl√®te** du sujet et une **progression p√©dagogique** coh√©rente.
</Aside>

### Generator Agent ‚úèÔ∏è

Le Generator **cr√©e les cartes** selon le plan √©tabli. Il utilise les chunks comme source de v√©rit√© et respecte le format de chaque type :

<Tabs>
  <TabItem label="Flashcard">
    ```python
    {
        "type": "flashcard",
        "question": "Qu'est-ce que la photosynth√®se ?",
        "answer": "La photosynth√®se est le processus par lequel...",
        "difficulty": 2,
        "tags": ["biologie", "plantes"]
    }
    ```
  </TabItem>
  
  <TabItem label="QCM">
    ```python
    {
        "type": "mcq",
        "question": "Quel organite r√©alise la photosynth√®se ?",
        "correct_answer": "Chloroplaste",
        "options": [
            "Chloroplaste",
            "Mitochondrie",
            "Ribosome",
            "Noyau"
        ],
        "explanation": "Les chloroplastes contiennent...",
        "difficulty": 3
    }
    ```
  </TabItem>
  
  <TabItem label="Vrai/Faux">
    ```python
    {
        "type": "true_or_false",
        "statement": "La photosynth√®se produit de l'oxyg√®ne.",
        "is_true": True,
        "explanation": "La photosynth√®se lib√®re de l'O2...",
        "difficulty": 1
    }
    ```
  </TabItem>
</Tabs>

### Critic Agent üîç

Le Critic est le **contr√¥le qualit√©** du syst√®me. Pour chaque carte g√©n√©r√©e, il √©value :

```python
class CardQualityScore(BaseModel):
    """Score de qualit√© calcul√© par le Critic.
    
    Chaque dimension est √©valu√©e de 0 √† 1, puis combin√©e
    en un score global sur 10.
    """
    clarity: float         # La question est-elle claire et compr√©hensible ?
    relevance: float       # La carte teste-t-elle bien le contenu source ?
    difficulty_fit: float  # Le niveau correspond-il √† celui demand√© ?
    uniqueness: float      # La carte est-elle diff√©rente des autres ?
    overall: float         # Score final = moyenne pond√©r√©e (0-10)
    suggestions: List[str] # Conseils pr√©cis pour am√©liorer la carte
```

<Aside type="caution" title="Les seuils de qualit√©">
  Ces seuils ont √©t√© calibr√©s empiriquement pour √©quilibrer qualit√© et performance :
</Aside>

| Crit√®re | Seuil | Explication |
|---------|-------|-------------|
| Score minimum | **7.5/10** | En dessous, la carte part au Refiner |
| Similarit√© max | **75%** | Au-del√†, consid√©r√© comme doublon |
| Tentatives max | **2** | Apr√®s 2 √©checs, la carte est rejet√©e |

### Refiner Agent üîß

Le Refiner **am√©liore les cartes** qui n'ont pas atteint le score minimum. Il re√ßoit la carte originale + les suggestions du Critic :

Le Refiner am√©liore les cartes selon le feedback du Critic :

<MermaidDownload title="Flux du Refiner">
```mermaid
graph LR
    A[Carte originale] --> B{Score < 7.5?}
    B -->|Non| C[Approuv√©e]
    B -->|Oui| D[Refiner]
    D --> E{Tentative < 2?}
    E -->|Oui| F[Carte am√©lior√©e]
    F --> G[Re-√©valuation]
    E -->|Non| H[Rejet√©e]
    
    style C fill:#c8e6c9
    style H fill:#ffcdd2
```
</MermaidDownload>

---

## Types Agent

### Actions de l'Agent

```python
class AgentActionType(str, Enum):
    """Types d'actions disponibles pour l'agent"""
    GENERATE = "generate"        # G√©n√©rer de nouvelles cartes
    EVALUATE = "evaluate"        # √âvaluer les cartes existantes
    REFINE = "refine"           # Am√©liorer une carte
    REMOVE_DUPLICATE = "remove"  # Supprimer un doublon
    FINALIZE = "finalize"       # Finaliser la collection
```

### D√©cisions de l'Agent

```python
class AgentDecision(str, Enum):
    """D√©cisions possibles apr√®s √©valuation"""
    APPROVE = "approve"          # Carte approuv√©e
    REFINE = "refine"           # N√©cessite am√©lioration
    REGENERATE = "regenerate"   # Reg√©n√©rer compl√®tement
    REJECT = "reject"           # Rejeter la carte
    FINISH = "finish"           # Terminer la g√©n√©ration
```

### R√©sultat du Critic

```python
class CritiqueResult(BaseModel):
    """R√©sultat de l'√©valuation par le Critic"""
    cards_approved: List[str]        # IDs des cartes approuv√©es
    cards_to_refine: List[str]       # IDs √† am√©liorer
    cards_to_reject: List[str]       # IDs √† rejeter
    duplicate_pairs: List[Tuple]     # Paires de doublons
    diversity_score: float           # Score de diversit√©
    needs_more_generation: bool      # Si plus de cartes n√©cessaires
```

---

## Optimisation des batches

Le module `batch_optimizer.py` calcule dynamiquement la taille des batches pour optimiser les appels LLM :

```python
@dataclass(frozen=True)
class BatchConfig:
    """Configuration de batch optimis√©e"""
    batch_size: int              # Nombre de cartes par batch
    estimated_input_tokens: int  # Tokens d'entr√©e estim√©s
    estimated_output_tokens: int # Tokens de sortie estim√©s
    total_batches: int           # Nombre total de batches
```

### Estimation des tokens par type

| Type de carte | Tokens output estim√©s |
|---------------|----------------------|
| Flashcard | 150 |
| QCM | 250 |
| Vrai/Faux | 120 |
| Match Pair | 200 |
| Texte libre | 180 |
| Classement | 220 |
| Drag & Drop | 280 |
| Slider | 100 |
| Geo Guess | 150 |

---

## Exemple d'utilisation

```python
from src.graphs.card_generator import card_generator_graph
from src.models.card_types import CardType, CardTypeRequest

# Configuration des types de cartes souhait√©s
card_requests = [
    CardTypeRequest(card_type=CardType.FLASHCARD, count=5),
    CardTypeRequest(card_type=CardType.MCQ, count=3),
    CardTypeRequest(card_type=CardType.TRUE_OR_FALSE, count=2)
]

# Invocation du graphe
result = await card_generator_graph.ainvoke({
    "embedded_chunks": embedded_chunks,  # Depuis le graphe d'embedding
    "card_type_requests": card_requests,
    "language": "fr",
    "user_context": "Sujet: Biologie - La photosynth√®se"
})

# R√©cup√©ration des r√©sultats
generated_cards = result["generated_cards"]
metadata = result["collection_metadata"]

print(f"Cartes g√©n√©r√©es: {len(generated_cards)}")
print(f"Score moyen: {metadata['average_quality_score']}")
```

---

## Prompts YAML

Les prompts des agents sont stock√©s dans `src/prompts/` au format YAML avec support multi-langue :

```yaml
# src/prompts/generator.yaml
system:
  fr: |
    Tu es un expert en cr√©ation de contenu p√©dagogique.
    Tu g√©n√®res des cartes d'apprentissage de haute qualit√©.
    
  en: |
    You are an expert in educational content creation.
    You generate high-quality learning cards.

user:
  fr: |
    G√©n√®re {count} cartes de type {card_type} √† partir du contenu suivant:
    {content}
    
    Niveau de difficult√©: {difficulty}
```

### Prompts disponibles

| Fichier | Agent | R√¥le |
|---------|-------|------|
| `planner.yaml` | Planner | Planification de la g√©n√©ration |
| `generator.yaml` | Generator | Cr√©ation des cartes |
| `critic.yaml` | Critic | √âvaluation de qualit√© |
| `refiner.yaml` | Refiner | Am√©lioration des cartes |

---

## M√©triques de qualit√©

| M√©trique | Description | Cible |
|----------|-------------|-------|
| **Score moyen** | Qualit√© moyenne des cartes | > 8.0/10 |
| **Taux d'approbation** | Cartes approuv√©es du premier coup | > 70% |
| **Doublons d√©tect√©s** | Cartes similaires identifi√©es | < 5% |
| **Couverture sujet** | % du contenu couvert | > 85% |
| **Diversit√© types** | √âquilibre entre les types | Selon config |

---

## Structure du code

<FileTree>
- src/
  - graphs/
    - **card_generator.py** üé¥ Graph principal
  - nodes/
    - card_generation/
      - validate_inputs.py
      - select_chunks.py
      - planner.py
      - generator.py
      - critic.py
      - refiner.py
      - finalizer.py
  - models/
    - **card_types.py** Types de cartes
    - **agent_types.py** Types agent
  - prompts/
    - planner.yaml
    - generator.yaml
    - critic.yaml
    - refiner.yaml
</FileTree>

---

*G√©n√©ration intelligente de cartes d'apprentissage gr√¢ce √† une architecture agentic.*
