---
/**
 * Composant MermaidDownload
 * Affiche un diagramme Mermaid avec zoom et téléchargement SVG
 *
 * Usage:
 * <MermaidDownload title="Mon diagramme">
 * ```mermaid
 * flowchart LR
 *     A --> B
 * ```
 * </MermaidDownload>
 */

interface Props {
  title?: string;
}

const { title = "diagram" } = Astro.props;
const uniqueId = `mermaid-${Math.random().toString(36).substring(2, 9)}`;
---

<div class="mermaid-container" data-mermaid-id={uniqueId}>
  <div class="mermaid-toolbar">
    <span class="mermaid-title">{title}</span>
    <div class="mermaid-buttons">
      <button class="tool-btn" data-action="zoom-out" title="Dézoomer">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <span class="zoom-level">100%</span>
      <button class="tool-btn" data-action="zoom-in" title="Zoomer">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <span class="separator"></span>
      <button
        class="tool-btn fullscreen-btn"
        data-action="fullscreen"
        title="Plein écran"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      </button>
      <span class="separator"></span>
      <button
        class="tool-btn download-btn"
        data-format="svg"
        title="Télécharger en SVG"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        SVG
      </button>
    </div>
  </div>
  <div class="mermaid-content">
    <div class="mermaid-zoom-wrapper">
      <slot />
    </div>
  </div>
</div>

<style>
  .mermaid-container {
    position: relative;
    margin: 1.5rem 0;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.5rem;
    overflow: hidden;
    background: var(--sl-color-bg);
  }

  .mermaid-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background: var(--sl-color-gray-6);
    border-bottom: 1px solid var(--sl-color-gray-5);
  }

  .mermaid-title {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--sl-color-text);
  }

  .mermaid-buttons {
    display: inline-flex;
    align-items: center;
    height: 32px;
    background: var(--sl-color-bg);
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 6px;
    overflow: hidden;
  }

  .tool-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 30px;
    padding: 0 8px;
    color: var(--sl-color-text);
    background: transparent;
    border: none;
    cursor: pointer;
    transition: background 0.15s ease;
    gap: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    line-height: 1;
  }

  .tool-btn svg {
    flex-shrink: 0;
  }

  .tool-btn:hover {
    background: var(--sl-color-gray-5);
  }

  .zoom-level {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 30px;
    min-width: 50px;
    padding: 0 4px;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--sl-color-text);
    border-left: 1px solid var(--sl-color-gray-5);
    border-right: 1px solid var(--sl-color-gray-5);
  }

  .separator {
    width: 1px;
    height: 20px;
    background: var(--sl-color-gray-5);
  }

  .mermaid-content {
    padding: 1rem;
    overflow: hidden;
    max-height: 70vh;
    position: relative;
  }

  .mermaid-zoom-wrapper {
    transform-origin: 0 0;
    transition: transform 0.1s ease;
    cursor: grab;
  }

  .mermaid-zoom-wrapper.dragging {
    cursor: grabbing;
    transition: none;
  }

  /* Mode plein écran */
  .mermaid-container:fullscreen {
    background: var(--sl-color-bg);
    display: flex;
    flex-direction: column;
  }

  .mermaid-container:fullscreen .mermaid-content {
    flex: 1;
    max-height: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .mermaid-container:fullscreen .mermaid-zoom-wrapper {
    transform-origin: center center;
  }

  .mermaid-content :global(pre) {
    margin: 0;
    background: transparent !important;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Attendre que Mermaid ait rendu les diagrammes
    setTimeout(() => {
      document.querySelectorAll(".mermaid-container").forEach((container) => {
        const downloadBtn = container.querySelector(".download-btn");
        const zoomBtns = container.querySelectorAll('[data-action^="zoom"]');
        const zoomLevelDisplay = container.querySelector(".zoom-level");
        const zoomWrapper = container.querySelector(
          ".mermaid-zoom-wrapper",
        ) as HTMLElement;
        const mermaidContent = container.querySelector(
          ".mermaid-content",
        ) as HTMLElement;
        const title =
          container.querySelector(".mermaid-title")?.textContent || "diagram";

        // État du zoom et position
        let zoomLevel = 100;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let startX = 0;
        let startY = 0;

        const minZoom = 25;
        const maxZoom = 800;
        const zoomStep = 25;

        // Fonction pour mettre à jour la transformation
        const updateTransform = () => {
          if (zoomWrapper) {
            zoomWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel / 100})`;
          }
          if (zoomLevelDisplay) {
            zoomLevelDisplay.textContent = `${zoomLevel}%`;
          }
        };

        // Gestion des boutons de zoom
        zoomBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            const action = btn.getAttribute("data-action");

            if (action === "zoom-in" && zoomLevel < maxZoom) {
              zoomLevel += zoomStep;
            } else if (action === "zoom-out" && zoomLevel > minZoom) {
              zoomLevel -= zoomStep;
            } else if (action === "zoom-reset") {
              zoomLevel = 100;
              panX = 0;
              panY = 0;
            }

            updateTransform();
          });
        });

        // Zoom à la molette de la souris (avec Ctrl/Cmd)
        container.addEventListener(
          "wheel",
          (e: Event) => {
            const wheelEvent = e as WheelEvent;
            if (wheelEvent.ctrlKey || wheelEvent.metaKey) {
              e.preventDefault();
              if (wheelEvent.deltaY < 0 && zoomLevel < maxZoom) {
                zoomLevel += zoomStep;
              } else if (wheelEvent.deltaY > 0 && zoomLevel > minZoom) {
                zoomLevel -= zoomStep;
              }
              updateTransform();
            }
          },
          { passive: false },
        );

        // Gestion du drag pour se déplacer
        if (mermaidContent && zoomWrapper) {
          mermaidContent.addEventListener("mousedown", (e: MouseEvent) => {
            // Ignorer si on clique sur un bouton
            if ((e.target as HTMLElement).closest("button")) return;

            isDragging = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            zoomWrapper.classList.add("dragging");
            e.preventDefault();
          });

          document.addEventListener("mousemove", (e: MouseEvent) => {
            if (!isDragging) return;

            panX = e.clientX - startX;
            panY = e.clientY - startY;
            updateTransform();
          });

          document.addEventListener("mouseup", () => {
            if (isDragging) {
              isDragging = false;
              zoomWrapper.classList.remove("dragging");
            }
          });

          // Support tactile
          mermaidContent.addEventListener(
            "touchstart",
            (e: TouchEvent) => {
              if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX - panX;
                startY = e.touches[0].clientY - panY;
                zoomWrapper.classList.add("dragging");
              }
            },
            { passive: true },
          );

          document.addEventListener(
            "touchmove",
            (e: TouchEvent) => {
              if (!isDragging || e.touches.length !== 1) return;

              panX = e.touches[0].clientX - startX;
              panY = e.touches[0].clientY - startY;
              updateTransform();
            },
            { passive: true },
          );

          document.addEventListener("touchend", () => {
            if (isDragging) {
              isDragging = false;
              zoomWrapper.classList.remove("dragging");
            }
          });
        }

        // Gestion du plein écran
        const fullscreenBtn = container.querySelector(".fullscreen-btn");
        let savedZoom = 100;
        let savedPanX = 0;
        let savedPanY = 0;

        if (fullscreenBtn) {
          fullscreenBtn.addEventListener("click", async () => {
            if (!document.fullscreenElement) {
              // Sauvegarder l'état actuel
              savedZoom = zoomLevel;
              savedPanX = panX;
              savedPanY = panY;

              await (container as HTMLElement).requestFullscreen();

              // Mettre le zoom à 250% en plein écran
              zoomLevel = 250;
              panX = 0;
              panY = 0;
              updateTransform();
            } else {
              await document.exitFullscreen();
            }
          });

          document.addEventListener("fullscreenchange", () => {
            // Restaurer le zoom quand on quitte le plein écran
            if (!document.fullscreenElement) {
              zoomLevel = savedZoom;
              panX = savedPanX;
              panY = savedPanY;
              updateTransform();
            }
          });
        }

        // Gestion du téléchargement SVG
        if (downloadBtn) {
          downloadBtn.addEventListener("click", async () => {
            const svgElement = mermaidContent?.querySelector(
              "svg",
            ) as SVGSVGElement;

            if (!svgElement) {
              console.error("SVG Mermaid not found");
              return;
            }

            const bbox = svgElement.getBBox();
            const width =
              svgElement.getAttribute("width") ||
              bbox.width ||
              svgElement.clientWidth ||
              800;
            const height =
              svgElement.getAttribute("height") ||
              bbox.height ||
              svgElement.clientHeight ||
              600;

            const svgClone = svgElement.cloneNode(true) as SVGSVGElement;
            svgClone.setAttribute("width", String(width));
            svgClone.setAttribute("height", String(height));

            if (!svgClone.getAttribute("xmlns")) {
              svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            }

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgClone);

            const svgBlob = new Blob([svgString], {
              type: "image/svg+xml;charset=utf-8",
            });
            const url = URL.createObjectURL(svgBlob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `${title.replace(/\s+/g, "-").toLowerCase()}.svg`;
            link.click();
            URL.revokeObjectURL(url);
          });
        }
      });
    }, 1000);
  });
</script>
