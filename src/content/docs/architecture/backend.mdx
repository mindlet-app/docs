---
title: Backend - API Laravel
description: Architecture technique d√©taill√©e de l'API backend Laravel de Mindlet
sidebar:
  order: 2
---

import { Aside, Badge, Card, CardGrid, Steps, TabItem, Tabs } from '@astrojs/starlight/components';
import MermaidDownload from '../../../components/MermaidDownload.astro';

# üîß Backend API Laravel

<Badge text="Laravel 12" variant="success" />
<Badge text="PHP 8.4" variant="caution" />
<Badge text="PostgreSQL 17" variant="note" />
<Badge text="Redis" variant="tip" />

## Vue d'ensemble

Le backend de Mindlet est une **API RESTful** d√©velopp√©e avec **Laravel 12**, con√ßue selon une architecture en couches (Layered Architecture) avec une s√©paration stricte des responsabilit√©s. Cette API constitue le point central de communication entre l'application mobile et le service d'intelligence artificielle.

### Ce que fait le backend

- üîê **Authentification** multi-providers (email/password, Google, Apple)
- üìö **Gestion des collections** et des cartes d'apprentissage
- üé¥ **Orchestration** de la g√©n√©ration de cartes via le service IA
- üìä **Suivi de progression** et sessions d'√©tude
- üí¨ **Messagerie temps r√©el** via WebSocket
- üè¢ **Gestion d'organisations** et collaboration

<Aside type="tip" title="Pourquoi Laravel 12 ?">
  Laravel offre un √©cosyst√®me mature et coh√©rent qui acc√©l√®re le d√©veloppement tout en garantissant la maintenabilit√©. Les fonctionnalit√©s natives comme **Horizon** (gestion des queues), **Sanctum** (authentification API), et **Reverb** (WebSocket) permettent de construire une API robuste sans d√©pendances externes complexes.
</Aside>

## Stack technique

| Composant | Technologie | R√¥le |
|-----------|-------------|------|
| **Framework** | Laravel 12.x | Structure applicative |
| **Langage** | PHP 8.4 | Typage strict, enums natifs |
| **Base de donn√©es** | PostgreSQL 17 | Stockage relationnel, JSONB |
| **Cache & Queues** | Redis 8.2 | Sessions, jobs asynchrones |
| **WebSocket** | Laravel Reverb | Temps r√©el bidirectionnel |
| **Auth** | Laravel Sanctum | Tokens API, OAuth |
| **Jobs** | Laravel Horizon | Monitoring des workers |
| **API Docs** | Scramble | G√©n√©ration OpenAPI |
| **Admin** | Filament 4.0 | Interface d'administration |
| **Stockage** | AWS S3 / MinIO | Fichiers et m√©dias |

## Architecture du code

L'organisation du code suit le pattern **Service Layer** enrichi de **DTOs** pour le transfert de donn√©es et de **Policies** pour l'autorisation :

<MermaidDownload title="Architecture en couches">
```mermaid
flowchart TB
    subgraph "Couche HTTP"
        REQ["üåê Request"]
        CTRL["Controllers"]
        RES["Resources"]
        MW["Middlewares"]
    end

    subgraph "Couche Validation"
        FR["Form Requests"]
        DTO["DTOs"]
    end

    subgraph "Couche M√©tier"
        SVC["Services"]
        POL["Policies"]
        EVT["Events"]
        JOB["Jobs"]
    end

    subgraph "Couche Donn√©es"
        MDL["Models"]
        ENUM["Enums"]
        DB[("PostgreSQL")]
    end

    REQ --> MW --> FR --> CTRL
    CTRL --> SVC
    FR --> DTO
    SVC --> MDL --> DB
    SVC --> EVT --> JOB
    CTRL --> POL
    CTRL --> RES

    style REQ fill:#1565c0,stroke:#1976d2
    style SVC fill:#2e7d32,stroke:#388e3c
    style MDL fill:#e65100,stroke:#f57c00
    style DB fill:#7b1fa2,stroke:#9c27b0
```
</MermaidDownload>

### Structure des dossiers

```
app/
‚îú‚îÄ‚îÄ Console/                    # Commandes Artisan
‚îú‚îÄ‚îÄ Dtos/                       # Data Transfer Objects
‚îÇ   ‚îú‚îÄ‚îÄ Ai/                     # DTOs pour l'IA
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GeneratedCards/     # DTOs par type de carte
‚îÇ   ‚îú‚îÄ‚îÄ CardGeneration/         # DTOs du flux de g√©n√©ration
‚îÇ   ‚îî‚îÄ‚îÄ Embedding/              # DTOs des embeddings
‚îú‚îÄ‚îÄ Enums/                      # √ânum√©rations typ√©es
‚îÇ   ‚îú‚îÄ‚îÄ Card/                   # CardType, CardDifficulty
‚îÇ   ‚îú‚îÄ‚îÄ Collection/             # Visibility, CollaboratorRole
‚îÇ   ‚îî‚îÄ‚îÄ Ai/                     # AiBatchStatus, CardGenerationStatus
‚îú‚îÄ‚îÄ Events/                     # √âv√©nements broadcast
‚îÇ   ‚îî‚îÄ‚îÄ CardGeneration/         # 6 √©v√©nements de g√©n√©ration
‚îú‚îÄ‚îÄ Exceptions/                 # Exceptions personnalis√©es
‚îú‚îÄ‚îÄ Http/
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/            # 22+ contr√¥leurs par domaine
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/             # Middlewares personnalis√©s
‚îÇ   ‚îú‚îÄ‚îÄ Requests/               # Form Requests (validation)
‚îÇ   ‚îî‚îÄ‚îÄ Resources/              # Transformateurs JSON
‚îú‚îÄ‚îÄ Jobs/                       # Jobs asynchrones
‚îÇ   ‚îî‚îÄ‚îÄ CardGeneration/         # GenerateCardsJob
‚îú‚îÄ‚îÄ Listeners/                  # √âcouteurs d'√©v√©nements
‚îú‚îÄ‚îÄ Models/                     # 35+ mod√®les Eloquent
‚îú‚îÄ‚îÄ Notifications/              # Notifications push/email
‚îú‚îÄ‚îÄ Policies/                   # Politiques d'autorisation
‚îú‚îÄ‚îÄ Providers/                  # Fournisseurs de services
‚îî‚îÄ‚îÄ Services/                   # Logique m√©tier
    ‚îú‚îÄ‚îÄ Ai/                     # Services IA (quota, historique)
    ‚îú‚îÄ‚îÄ CardGeneration/         # Orchestration de g√©n√©ration
    ‚îî‚îÄ‚îÄ LangGraph/              # Client service IA
```

## Design Patterns utilis√©s

L'architecture du backend repose sur plusieurs design patterns reconnus, chacun r√©pondant √† une probl√©matique sp√©cifique :

<Tabs>
  <TabItem label="Service Layer">
    ### Pattern Service Layer

    **Objectif** : Centraliser la logique m√©tier dans des classes d√©di√©es, ind√©pendantes du framework HTTP.

    Ce pattern permet de :
    - **D√©coupler** la logique m√©tier des contr√¥leurs
    - **R√©utiliser** la m√™me logique depuis diff√©rents points d'entr√©e (API, Jobs, Console)
    - **Tester** unitairement sans d√©pendances HTTP

    ```php
    // app/Services/CardGeneration/CardGenerationService.php
    class CardGenerationService
    {
        public function __construct(
            private readonly QuotaService $quotaService,
            private readonly LangGraphGeneratorService $generator,
            private readonly CardPersistenceService $persistence,
            private readonly GenerationHistoryService $history,
        ) {}

        /**
         * Dispatche une g√©n√©ration de cartes de mani√®re asynchrone.
         *
         * @throws QuotaExceededException Si le quota utilisateur est d√©pass√©
         */
        public function dispatchGeneration(
            User $user,
            CardGenerationInput $input
        ): CardGenerationDispatchResult {
            // 1. V√©rification du quota
            $this->quotaService->guardCanGenerate(
                $user,
                $input->getTotalCardsRequested()
            );

            // 2. Enregistrement dans l'historique
            $generation = $this->history->recordRequest($user, $input);

            // 3. Dispatch du job asynchrone
            GenerateCardsJob::dispatch(
                $user->id,
                $generation->generation_id,
                $input
            );

            return new CardGenerationDispatchResult(
                generationId: $generation->generation_id,
                status: CardGenerationStatus::QUEUED,
                totalCardsRequested: $input->getTotalCardsRequested(),
            );
        }
    }
    ```

    <Aside type="note">
      Les services sont inject√©s via le **Service Container** de Laravel, facilitant les tests avec des mocks et la substitution d'impl√©mentations.
    </Aside>
  </TabItem>

  <TabItem label="DTO Pattern">
    ### Pattern Data Transfer Object (DTO)

    **Objectif** : Encapsuler les donn√©es transitant entre les couches dans des objets fortement typ√©s.

    Les DTOs garantissent :
    - **Typage fort** : validation √† la compilation
    - **Immutabilit√©** : donn√©es readonly apr√®s cr√©ation
    - **Documentation** : structure explicite des donn√©es

    ```php
    // app/Dtos/CardGeneration/CardGenerationInput.php
    readonly class CardGenerationInput
    {
        /**
         * @param CardTypeRequest[] $cardTypes Types et quantit√©s demand√©s
         */
        public function __construct(
            public LanguageCode $language,
            public array $cardTypes,
            public ?string $prompt = null,
            public ?string $userContext = null,
            public ?string $batchId = null,
            public ?string $collectionId = null,
            public CardDifficulty $difficulty = CardDifficulty::INTERMEDIATE,
        ) {}

        public function getTotalCardsRequested(): int
        {
            return array_sum(
                array_map(fn($ct) => $ct->count, $this->cardTypes)
            );
        }

        /**
         * Cr√©e un DTO depuis une Form Request valid√©e.
         */
        public static function fromRequest(GenerateCardsRequest $request): self
        {
            return new self(
                language: $request->enum('language', LanguageCode::class),
                cardTypes: $request->getCardTypeRequests(),
                prompt: $request->validated('prompt'),
                userContext: $request->validated('user_context'),
                batchId: $request->validated('batch_id'),
                collectionId: $request->validated('collection_id'),
                difficulty: $request->enum('difficulty', CardDifficulty::class)
                    ?? CardDifficulty::INTERMEDIATE,
            );
        }
    }
    ```

    **Exemple de transformation DTO ‚Üí Payload Base de donn√©es :**

    ```php
    // app/Dtos/Ai/GeneratedCards/FlashcardGeneratedCard.php
    class FlashcardGeneratedCard implements GeneratedCardDto
    {
        use TruncatesText;

        private function __construct(
            private string $question,
            private string $answer,
            private ?string $explanation,
        ) {}

        public static function fromArray(array $data): self
        {
            return new self(
                question: self::truncate($data['question'] ?? '', 2000),
                answer: self::truncate($data['answer'] ?? '', 5000),
                explanation: isset($data['explanation'])
                    ? self::truncate($data['explanation'], 2000)
                    : null,
            );
        }

        public function toPayload(): GeneratedCardPayload
        {
            return new GeneratedCardPayload(
                type: CardType::FLASHCARD,
                data: [
                    'question' => ['text' => $this->question],
                    'answer' => [
                        'value' => $this->answer,
                        'explanation' => $this->explanation,
                    ],
                ],
            );
        }
    }
    ```
  </TabItem>

  <TabItem label="Policy Pattern">
    ### Pattern Authorization Policy

    **Objectif** : Centraliser les r√®gles d'autorisation par ressource dans des classes d√©di√©es.

    Laravel impl√©mente nativement ce pattern avec les **Policies**, permettant de :
    - **Exprimer** clairement les r√®gles d'acc√®s
    - **R√©utiliser** les v√©rifications dans toute l'application
    - **Auditer** facilement les permissions

    ```php
    // app/Policies/CollectionPolicy.php
    #[UsePolicy(CollectionPolicy::class)]
    class CollectionPolicy
    {
        /**
         * D√©termine si l'utilisateur peut voir la collection.
         */
        public function view(User $user, Collection $collection): bool
        {
            // Propri√©taire
            if ($collection->owner_id === $user->id) {
                return true;
            }

            // Collection publique
            if ($collection->visibility === CollectionVisibility::PUBLIC) {
                return true;
            }

            // Collaborateur
            return $collection->collaborators()
                ->where('user_id', $user->id)
                ->exists();
        }

        /**
         * D√©termine si l'utilisateur peut modifier la collection.
         */
        public function update(User $user, Collection $collection): bool
        {
            if ($collection->owner_id === $user->id) {
                return true;
            }

            return $collection->collaborators()
                ->where('user_id', $user->id)
                ->where('role', CollaboratorRole::EDITOR)
                ->exists();
        }

        /**
         * D√©termine si l'utilisateur peut supprimer la collection.
         */
        public function delete(User $user, Collection $collection): bool
        {
            return $collection->owner_id === $user->id;
        }
    }
    ```

    **Utilisation dans un contr√¥leur :**

    ```php
    public function update(UpdateCollectionRequest $request, Collection $collection)
    {
        // V√©rifie automatiquement CollectionPolicy::update()
        $this->authorize('update', $collection);

        $collection->update($request->validated());

        return new CollectionResource($collection);
    }
    ```
  </TabItem>

  <TabItem label="Event-Driven">
    ### Pattern Event-Driven Architecture

    **Objectif** : D√©coupler les actions de leurs effets secondaires via un syst√®me d'√©v√©nements.

    Ce pattern permet de :
    - **Notifier** le client en temps r√©el (WebSocket)
    - **D√©clencher** des actions sans couplage fort
    - **Tracer** le flux d'ex√©cution

    ```php
    // app/Events/CardGeneration/CardGenerationCompleted.php
    class CardGenerationCompleted implements ShouldBroadcastNow
    {
        use Dispatchable, InteractsWithSockets, SerializesModels;

        public function __construct(
            public readonly string $userId,
            public readonly string $generationId,
            public readonly string $collectionId,
            public readonly int $totalCardsGenerated,
            public readonly int $totalCardsPersisted,
        ) {}

        /**
         * Canal de diffusion (priv√© par utilisateur).
         */
        public function broadcastOn(): array
        {
            return [
                new PrivateChannel("users.{$this->userId}"),
            ];
        }

        /**
         * Nom de l'√©v√©nement c√¥t√© client.
         */
        public function broadcastAs(): string
        {
            return 'card.generation.completed';
        }

        /**
         * Donn√©es envoy√©es au client.
         */
        public function broadcastWith(): array
        {
            return [
                'generation_id' => $this->generationId,
                'status' => 'completed',
                'collection_id' => $this->collectionId,
                'total_cards_generated' => $this->totalCardsGenerated,
                'total_cards_persisted' => $this->totalCardsPersisted,
            ];
        }
    }
    ```

    **Cha√Æne d'√©v√©nements de g√©n√©ration de cartes :**

    ```mermaid
    sequenceDiagram
        participant J as GenerateCardsJob
        participant E as Events
        participant WS as WebSocket
        participant C as Client Mobile

        J->>E: CardGenerationStarted
        E->>WS: Broadcast
        WS->>C: Notification "En cours..."

        J->>E: CardsGenerated
        E->>WS: Broadcast
        WS->>C: Progress update

        J->>E: CollectionCreated (si nouvelle)
        J->>E: CardsPersisted

        J->>E: CardGenerationCompleted
        E->>WS: Broadcast
        WS->>C: Notification "Termin√©!"
    ```
  </TabItem>
</Tabs>

## √ânum√©rations typ√©es (Enums)

PHP 8.1+ permet l'utilisation d'√©num√©rations natives. Mindlet les utilise intensivement pour garantir la coh√©rence des donn√©es :

<Tabs>
  <TabItem label="Types de cartes">
    ```php
    // app/Enums/Card/CardType.php
    enum CardType: string
    {
        case FLASHCARD = 'flashcard';           // Question/R√©ponse
        case MCQ = 'mcq';                       // QCM
        case FREE_TEXT = 'free_text';           // R√©ponse libre
        case TRUE_OR_FALSE = 'true_or_false';   // Vrai/Faux
        case SLIDER = 'slider';                 // Estimation num√©rique
        case MATCH_PAIRS = 'match_pairs';       // Associer des paires
        case DRAG_AND_DROP = 'drag_and_drop';   // Glisser-d√©poser
        case RANKING = 'ranking';               // Classement
        case GEO_GUESS = 'geo_guess';           // G√©olocalisation

        public function label(): string
        {
            return match($this) {
                self::FLASHCARD => 'Flashcard',
                self::MCQ => 'QCM',
                self::FREE_TEXT => 'R√©ponse libre',
                // ...
            };
        }
    }
    ```
  </TabItem>

  <TabItem label="Statuts de g√©n√©ration">
    ```php
    // app/Enums/Ai/CardGenerationStatus.php
    enum CardGenerationStatus: string
    {
        case QUEUED = 'queued';         // En file d'attente
        case PROCESSING = 'processing'; // En cours de g√©n√©ration
        case COMPLETED = 'completed';   // Termin√© avec succ√®s
        case FAILED = 'failed';         // √âchec

        public function isTerminal(): bool
        {
            return in_array($this, [self::COMPLETED, self::FAILED]);
        }
    }
    ```
  </TabItem>

  <TabItem label="Visibilit√©">
    ```php
    // app/Enums/Collection/CollectionVisibility.php
    enum CollectionVisibility: string
    {
        case PRIVATE = 'private';   // Seul le propri√©taire
        case PUBLIC = 'public';     // Visible par tous
        case DRAFT = 'draft';       // Brouillon (non list√©)
    }

    // app/Enums/Collection/CollaboratorRole.php
    enum CollaboratorRole: string
    {
        case VIEWER = 'viewer';   // Lecture seule
        case EDITOR = 'editor';   // Modification autoris√©e
    }
    ```
  </TabItem>
</Tabs>

## Mod√®les Eloquent

Les mod√®les Eloquent repr√©sentent les entit√©s m√©tier et encapsulent les relations, accesseurs et casts :

### Mod√®le Card (exemple comment√©)

```php
// app/Models/Card.php
class Card extends Model
{
    use HasFactory, SoftDeletes;
    use InteractsWithMedia; // Spatie Media Library
    use LogsActivity;       // Audit trail

    /**
     * Table avec UUID comme cl√© primaire.
     */
    protected $keyType = 'string';
    public $incrementing = false;

    /**
     * Attributs assignables en masse.
     */
    protected $fillable = [
        'collection_id',
        'type',
        'data',      // JSONB : question, r√©ponse, options
        'config',    // JSONB : comportement, feedback
        'metadata',  // JSONB : tags, niveau, source
    ];

    /**
     * Casting automatique des attributs.
     *
     * - CardType::class : conversion automatique string ‚Üî enum
     * - 'array' : JSON ‚Üî array PHP
     */
    protected $casts = [
        'type' => CardType::class,
        'data' => 'array',
        'config' => 'array',
        'metadata' => 'array',
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RELATIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    public function collection(): BelongsTo
    {
        return $this->belongsTo(Collection::class);
    }

    public function progressions(): HasMany
    {
        return $this->hasMany(CardProgression::class);
    }

    /**
     * Progression de l'utilisateur courant.
     */
    public function userProgression(): HasOne
    {
        return $this->hasOne(CardProgression::class)
            ->where('user_id', auth()->id());
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ACCESSEURS (colonnes virtuelles)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    /**
     * Acc√®s simplifi√© √† data.question.text
     */
    protected function question(): Attribute
    {
        return Attribute::get(
            fn() => $this->data['question']['text'] ?? null
        );
    }

    /**
     * Acc√®s simplifi√© √† data.answer.value
     */
    protected function answer(): Attribute
    {
        return Attribute::get(
            fn() => $this->data['answer']['value'] ?? null
        );
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MEDIA LIBRARY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    public function registerMediaCollections(): void
    {
        $this->addMediaCollection('attachments')
            ->acceptsMimeTypes([
                'image/jpeg', 'image/png', 'image/webp',
                'audio/mpeg', 'audio/wav',
            ]);
    }
}
```

<Aside type="note" title="Colonnes JSONB">
  PostgreSQL offre le type **JSONB** qui permet de stocker des donn√©es JSON avec indexation et requ√™tes efficaces. Cela √©vite de cr√©er des tables suppl√©mentaires pour les donn√©es polymorphes comme les diff√©rents types de cartes.
</Aside>

## Jobs asynchrones

Les t√¢ches longues sont d√©l√©gu√©es √† des **Jobs** ex√©cut√©s en arri√®re-plan via **Laravel Horizon** :

### GenerateCardsJob (exemple complet)

```php
// app/Jobs/CardGeneration/GenerateCardsJob.php
class GenerateCardsJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Nombre maximum de tentatives.
     */
    public int $tries = 5;

    /**
     * Timeout en secondes (10 minutes pour l'IA).
     */
    public int $timeout = 600;

    /**
     * File d'attente d√©di√©e aux jobs IA.
     */
    public string $queue = 'ai';

    private int $waitAttempts = 0;
    private const MAX_WAIT_ATTEMPTS = 10;

    public function __construct(
        private readonly string $userId,
        private readonly string $generationId,
        private readonly CardGenerationInput $input,
    ) {}

    public function handle(
        CardGenerationService $service,
        GenerationHistoryService $history,
    ): void {
        $user = User::findOrFail($this->userId);

        // 1. Marquer comme "en cours"
        $history->markProcessing($this->generationId);
        event(new CardGenerationStarted(
            $this->userId,
            $this->generationId,
            $this->input->getTotalCardsRequested()
        ));

        // 2. Attendre que le batch soit pr√™t (si applicable)
        if ($this->input->batchId) {
            $this->guardBatchIsReady($this->input->batchId);
        }

        // 3. G√©n√©rer les cartes
        $result = $service->generate($user, $this->input);

        event(new CardsGenerated(
            $this->userId,
            $this->generationId,
            $result->stats->cardsGenerated
        ));

        // 4. Persister en base
        $persistenceResult = app(CardPersistenceService::class)
            ->persist($user, $result, $this->input);

        if ($persistenceResult->collectionCreated) {
            event(new CollectionCreated(
                $this->userId,
                $this->generationId,
                $persistenceResult->collectionId,
                $persistenceResult->collectionTitle
            ));
        }

        event(new CardsPersisted(
            $this->userId,
            $this->generationId,
            $persistenceResult->collectionId,
            $persistenceResult->cardsPersisted
        ));

        // 5. Consommer le quota APR√àS la persistance
        app(QuotaService::class)->consumeQuota(
            $user,
            $result->stats->cardsGenerated
        );

        // 6. Mettre √† jour l'historique
        $history->markCompleted(
            $this->generationId,
            $persistenceResult->collectionId,
            $result->stats
        );

        // 7. Notifier le succ√®s
        event(new CardGenerationCompleted(
            $this->userId,
            $this->generationId,
            $persistenceResult->collectionId,
            $result->stats->cardsGenerated,
            $persistenceResult->cardsPersisted
        ));
    }

    /**
     * Attente active pour la pr√©paration du batch d'embeddings.
     */
    private function guardBatchIsReady(string $batchId): void
    {
        $batch = AiResourceBatch::findOrFail($batchId);

        if ($batch->status === AiBatchStatus::COMPLETED) {
            return;
        }

        if ($this->waitAttempts >= self::MAX_WAIT_ATTEMPTS) {
            throw new BatchNotReadyException(
                "Batch $batchId not ready after max attempts"
            );
        }

        $this->waitAttempts++;
        $delay = min(5 + ($this->waitAttempts * 5), 30); // 5s ‚Üí 30s

        $this->release($delay); // Rel√¢che le job, sera r√©essay√©
    }

    /**
     * Gestion des √©checs.
     */
    public function failed(\Throwable $exception): void
    {
        app(GenerationHistoryService::class)->markFailed(
            $this->generationId,
            $exception->getMessage()
        );

        event(new CardGenerationFailed(
            $this->userId,
            $this->generationId,
            $exception->getMessage(),
            $this->input->batchId
        ));
    }
}
```

<Aside type="caution" title="Consommation du quota">
  Le quota n'est consomm√© qu'**apr√®s** la persistance r√©ussie des cartes. Cela garantit que l'utilisateur n'est pas factur√© en cas d'√©chec technique.
</Aside>

## Communication avec le service IA

L'int√©gration avec le service **LangGraph** se fait via un client HTTP d√©di√© :

<MermaidDownload title="Communication Backend ‚Üí Service IA">
```mermaid
sequenceDiagram
    participant Job as GenerateCardsJob
    participant SVC as LangGraphGeneratorService
    participant Client as LangGraphClient
    participant IA as LangGraph Cloud

    Job->>SVC: generate(user, input)
    SVC->>SVC: buildInput(embeddings, params)
    SVC->>Client: runWait(payload)

    Client->>IA: POST /runs/wait
    Note over Client,IA: Timeout: 300s<br/>Retries: 3x avec backoff

    IA-->>Client: { generated_cards, metadata }
    Client-->>SVC: Response array

    SVC->>SVC: parseResponse()
    SVC-->>Job: CardGenerationResult
```
</MermaidDownload>

### LangGraphClient

```php
// app/Services/LangGraph/LangGraphClient.php
class LangGraphClient
{
    private const MAX_RETRIES = 3;
    private const MAX_BACKOFF_MS = 5000;

    public function __construct(
        private readonly string $baseUrl,
        private readonly string $apiKey,
        private readonly float $connectTimeout = 5.0,
        private readonly float $readTimeout = 300.0,
    ) {}

    /**
     * Ex√©cute une requ√™te synchrone avec attente du r√©sultat.
     */
    public function runWait(array $payload): array
    {
        return $this->post('/runs/wait', $payload);
    }

    /**
     * POST avec retry et backoff exponentiel.
     */
    private function post(string $path, array $payload): array
    {
        $attempt = 0;
        $lastException = null;

        while ($attempt < self::MAX_RETRIES) {
            try {
                $response = Http::baseUrl($this->baseUrl)
                    ->withToken($this->apiKey)
                    ->timeout($this->readTimeout)
                    ->connectTimeout($this->connectTimeout)
                    ->post($path, $payload);

                if ($response->successful()) {
                    return $response->json();
                }

                throw new \RuntimeException(
                    "LangGraph error: {$response->status()}"
                );

            } catch (\Exception $e) {
                $lastException = $e;
                $attempt++;

                if ($attempt < self::MAX_RETRIES) {
                    $backoff = min(
                        (2 ** $attempt) * 100 + random_int(0, 100),
                        self::MAX_BACKOFF_MS
                    );
                    usleep($backoff * 1000);
                }
            }
        }

        throw $lastException;
    }
}
```

## Validation des requ√™tes

La validation est centralis√©e dans des **Form Requests** avec des r√®gles d√©claratives :

```php
// app/Http/Requests/CardGeneration/GenerateCardsRequest.php
class GenerateCardsRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            // Prompt requis si pas de batch
            'prompt' => [
                'nullable',
                'string',
                'max:5000',
                Rule::requiredIf(fn() => !$this->filled('batch_id')),
            ],

            // Langue obligatoire (enum valid√©)
            'language' => [
                'required',
                Rule::enum(LanguageCode::class),
            ],

            // Contexte utilisateur optionnel
            'user_context' => ['nullable', 'string', 'max:2000'],

            // Batch ID requis si pas de prompt
            'batch_id' => [
                'nullable',
                'uuid',
                Rule::requiredIf(fn() => !$this->filled('prompt')),
                $this->batchExistsRule(),
            ],

            // Collection cible (optionnelle)
            'collection_id' => [
                'nullable',
                'uuid',
                Rule::exists('collections', 'id'),
            ],

            // Difficult√© (enum optionnel)
            'difficulty' => [
                'sometimes',
                Rule::enum(CardDifficulty::class),
            ],

            // Types de cartes demand√©s
            'card_types' => ['required', 'array', 'min:1'],
            'card_types.*.card_type' => [
                'required',
                Rule::enum(CardType::class),
            ],
            'card_types.*.count' => [
                'required',
                'integer',
                'min:1',
                'max:50',
            ],
        ];
    }

    /**
     * R√®gle personnalis√©e : le batch doit appartenir √† l'utilisateur.
     */
    private function batchExistsRule(): \Closure
    {
        return function ($attribute, $value, $fail) {
            $exists = AiResourceBatch::query()
                ->where('id', $value)
                ->where('user_id', $this->user()->id)
                ->exists();

            if (!$exists) {
                $fail("Le batch sp√©cifi√© n'existe pas.");
            }
        };
    }

    /**
     * Conversion vers DTO apr√®s validation.
     */
    public function toDto(): CardGenerationInput
    {
        return CardGenerationInput::fromRequest($this);
    }
}
```

## Documentation de l'API

L'API est document√©e automatiquement via **Scramble**, qui g√©n√®re une sp√©cification **OpenAPI 3.0** √† partir du code :

### Configuration Scramble

```php
// config/scramble.php
return [
    'api_path' => 'api',
    'export_path' => 'api.json',

    'ui' => [
        'theme' => 'light',
        'layout' => 'responsive',
    ],

    // Sch√©ma de s√©curit√©
    'security' => [
        'default' => [
            ['bearerAuth' => []],
        ],
    ],
];

// AppServiceProvider.php
Scramble::configure()
    ->withDocumentTransformers(function (OpenApi $openApi) {
        $openApi->secure(
            SecurityScheme::http('bearer', 'JWT')
        );
    });
```

**R√©sultat** : Documentation interactive accessible √† `/docs/api`

<Aside type="tip" title="Avantage de Scramble">
  Contrairement aux annotations manuelles, Scramble **inf√®re** automatiquement les types depuis le code PHP, les Form Requests et les Resources. La documentation reste toujours synchronis√©e avec l'impl√©mentation.
</Aside>

## Authentification et s√©curit√©

<Tabs>
  <TabItem label="Sanctum">
    ### Laravel Sanctum

    L'authentification API utilise **Laravel Sanctum** avec des tokens Bearer :

    ```php
    // G√©n√©ration d'un token
    $token = $user->createToken('mobile-app', ['*']);

    // Header de requ√™te
    Authorization: Bearer {token}
    ```

    **Flux d'authentification :**

    <Steps>
    1. L'utilisateur envoie ses credentials (email/password ou OAuth)
    2. L'API valide et g√©n√®re un **access token** (courte dur√©e) et un **refresh token**
    3. Le client stocke les tokens de mani√®re s√©curis√©e
    4. Chaque requ√™te inclut l'access token dans le header `Authorization`
    5. Le middleware `auth:sanctum` v√©rifie le token
    6. √Ä expiration, le client utilise le refresh token pour en obtenir un nouveau
    </Steps>

    <MermaidDownload title="Flux d'authentification Sanctum">
    ```mermaid
    sequenceDiagram
        autonumber
        participant Client as üì± Mobile App
        participant API as üñ•Ô∏è Laravel API
        participant MW as üîí Middleware Sanctum
        participant DB as üóÑÔ∏è PostgreSQL

        rect rgb(46, 125, 50)
            Note over Client,DB: Phase 1 : Authentification initiale
            Client->>+API: POST /auth/login<br/>{email, password}
            API->>+DB: V√©rifier credentials
            DB-->>-API: User trouv√© ‚úì
            API->>DB: Cr√©er personal_access_token
            API-->>-Client: 200 OK<br/>{access_token, refresh_token, expires_in}
            Client->>Client: Stocker tokens (SecureStore)
        end

        rect rgb(21, 101, 192)
            Note over Client,DB: Phase 2 : Requ√™tes authentifi√©es
            Client->>+API: GET /api/collections<br/>Authorization: Bearer {token}
            API->>+MW: V√©rifier token
            MW->>+DB: SELECT * FROM personal_access_tokens
            DB-->>-MW: Token valide ‚úì
            MW-->>-API: User authentifi√©
            API->>DB: Fetch collections
            API-->>-Client: 200 OK<br/>{collections: [...]}
        end

        rect rgb(230, 81, 0)
            Note over Client,DB: Phase 3 : Rafra√Æchissement du token
            Client->>+API: POST /auth/refresh<br/>{refresh_token}
            API->>+DB: V√©rifier refresh_token
            DB-->>-API: Token valide ‚úì
            API->>DB: R√©voquer ancien access_token
            API->>DB: Cr√©er nouveau access_token
            API-->>-Client: 200 OK<br/>{access_token, expires_in}
        end

        rect rgb(198, 40, 40)
            Note over Client,DB: Cas d'erreur : Token expir√©
            Client->>+API: GET /api/cards<br/>Authorization: Bearer {expired_token}
            API->>+MW: V√©rifier token
            MW->>DB: SELECT * FROM personal_access_tokens
            MW-->>-API: Token expir√© ‚úó
            API-->>-Client: 401 Unauthorized
            Client->>Client: D√©clencher refresh flow
        end
    ```
    </MermaidDownload>

    **Explication du diagramme :**

    - **Phase 1** : L'utilisateur s'authentifie avec ses credentials. L'API g√©n√®re deux tokens : un `access_token` de courte dur√©e (1h) et un `refresh_token` de longue dur√©e (30 jours).
    - **Phase 2** : Chaque requ√™te API inclut l'access token. Le middleware Sanctum v√©rifie sa validit√© dans la table `personal_access_tokens`.
    - **Phase 3** : Avant expiration, le client utilise le refresh token pour obtenir un nouvel access token sans re-authentification.
    - **Cas d'erreur** : Si le token est expir√©, l'API retourne une erreur 401 et le client d√©clenche automatiquement le flow de refresh.
  </TabItem>

  <TabItem label="OAuth">
    ### OAuth (Google, Apple)

    ```php
    // app/Http/Controllers/Auth/OAuthController.php
    public function callback(OAuthCallbackRequest $request)
    {
        $provider = $request->validated('provider');
        $code = $request->validated('code');
        $codeVerifier = $request->validated('code_verifier'); // PKCE

        // √âchange du code contre un token
        $tokenResponse = $this->exchangeCode(
            $provider,
            $code,
            $codeVerifier
        );

        // R√©cup√©ration des infos utilisateur
        $userInfo = $this->getUserInfo($provider, $tokenResponse);

        // Cr√©ation ou r√©cup√©ration de l'utilisateur
        $user = User::firstOrCreate(
            ['email' => $userInfo['email']],
            [
                'name' => $userInfo['name'],
                'email_verified_at' => now(),
            ]
        );

        // Liaison du compte social
        $user->socialAccounts()->updateOrCreate(
            ['provider' => $provider],
            ['provider_user_id' => $userInfo['id']]
        );

        return $this->issueTokens($user);
    }
    ```
  </TabItem>

  <TabItem label="Middlewares">
    ### Middlewares de s√©curit√©

    ```php
    // routes/api.php
    Route::middleware([
        'auth:sanctum',       // Authentification obligatoire
        'throttle:api',       // Rate limiting (60 req/min)
        'verified',           // Email v√©rifi√© requis
    ])->group(function () {
        // Routes prot√©g√©es
        Route::apiResource('collections', CollectionController::class);
        Route::post('cards/generate', GenerateCardsController::class);
    });
    ```

    **Configuration du rate limiting :**

    ```php
    // app/Providers/AppServiceProvider.php
    RateLimiter::for('api', function (Request $request) {
        return Limit::perMinute(60)
            ->by($request->user()?->id ?: $request->ip());
    });
    ```
  </TabItem>
</Tabs>

## Base de donn√©es

### Migrations principales

Les migrations versionnent le sch√©ma de base de donn√©es :

```php
// database/migrations/xxxx_create_cards_table.php
Schema::create('cards', function (Blueprint $table) {
    $table->uuid('id')->primary();
    $table->foreignUuid('collection_id')
        ->constrained()
        ->cascadeOnDelete();

    $table->string('type');          // Enum stock√© en string
    $table->jsonb('data');           // Question, r√©ponse, options
    $table->jsonb('config')->nullable();
    $table->jsonb('metadata')->nullable();

    $table->timestamps();
    $table->softDeletes();

    // Index composites pour les requ√™tes fr√©quentes
    $table->index(['collection_id', 'type']);
    $table->index('type');
});
```

### Relations entre entit√©s

<MermaidDownload title="Relations principales">
```mermaid
erDiagram
    USERS ||--o{ COLLECTIONS : owns
    USERS ||--o{ AI_CARD_GENERATIONS : requests
    USERS ||--|| USER_AI_QUOTAS : has
    USERS ||--o{ AI_RESOURCE_BATCHES : submits

    COLLECTIONS ||--o{ CARDS : contains
    COLLECTIONS ||--o{ COLLECTION_COLLABORATORS : has
    COLLECTIONS ||--o{ STUDY_SESSIONS : studied_in

    CARDS ||--o{ CARD_PROGRESSIONS : tracks

    AI_RESOURCE_BATCHES ||--o{ AI_RESOURCE_ITEMS : contains
    AI_RESOURCE_ITEMS ||--o{ AI_RESOURCE_EMBEDDINGS : has

    USERS {
        uuid id PK
        string name
        string email
        timestamp email_verified_at
    }

    COLLECTIONS {
        uuid id PK
        uuid owner_id FK
        string title
        string visibility
    }

    CARDS {
        uuid id PK
        uuid collection_id FK
        string type
        jsonb data
    }

    AI_CARD_GENERATIONS {
        uuid id PK
        uuid user_id FK
        string status
        int cards_generated
    }
```
</MermaidDownload>

## Gestion des quotas

Le syst√®me de quotas limite l'utilisation des ressources IA :

```php
// app/Services/Ai/QuotaService.php
class QuotaService
{
    private const DEFAULT_DAILY_LIMIT = 30;
    private const DEFAULT_MONTHLY_LIMIT = 100;
    private const DEFAULT_MAX_PER_GENERATION = 50;

    /**
     * V√©rifie si l'utilisateur peut g√©n√©rer des cartes.
     */
    public function guardCanGenerate(User $user, int $cardsRequested): void
    {
        $quota = $this->getOrCreateQuota($user);

        // Utilisateur illimit√© (admin, premium)
        if ($quota->is_unlimited) {
            return;
        }

        // Reset automatique des compteurs
        $this->resetIfNeeded($quota);

        // V√©rification des limites
        if ($cardsRequested > self::DEFAULT_MAX_PER_GENERATION) {
            throw new QuotaExceededException(
                "Maximum {self::DEFAULT_MAX_PER_GENERATION} cartes par g√©n√©ration"
            );
        }

        if ($quota->daily_generations_used >= $quota->daily_generation_limit) {
            throw new QuotaExceededException(
                "Limite quotidienne atteinte"
            );
        }

        if ($quota->monthly_generations_used >= $quota->monthly_generation_limit) {
            throw new QuotaExceededException(
                "Limite mensuelle atteinte"
            );
        }
    }

    /**
     * Consomme le quota apr√®s g√©n√©ration r√©ussie.
     */
    public function consumeQuota(User $user, int $cardsGenerated): void
    {
        $quota = $this->getOrCreateQuota($user);

        $quota->increment('daily_generations_used');
        $quota->increment('monthly_generations_used');
        $quota->increment('total_generations_used');
        $quota->increment('total_cards_generated', $cardsGenerated);
    }
}
```

## R√©sum√© des technologies

| Cat√©gorie | Technologies |
|-----------|--------------|
| **Core** | Laravel 12, PHP 8.4, PostgreSQL 17 |
| **Auth** | Sanctum, OAuth 2.0 (Google, Apple) |
| **Async** | Redis, Laravel Horizon, Jobs |
| **Real-time** | Laravel Reverb (WebSocket) |
| **Storage** | AWS S3, Spatie Media Library |
| **Validation** | Form Requests, Enums, DTOs |
| **Docs** | Scramble (OpenAPI 3.0) |
| **Admin** | Filament 4.0 |

<CardGrid>
  <Card title="Service IA" icon="rocket">
    D√©couvrez comment le backend communique avec le service d'intelligence artificielle.

    [Voir le Service IA ‚Üí](/architecture/service-ia/)
  </Card>
  <Card title="Frontend Mobile" icon="laptop">
    Explorez l'architecture de l'application React Native.

    [Voir le Frontend ‚Üí](/architecture/frontend/)
  </Card>
</CardGrid>

---

*Backend con√ßu pour la robustesse, la scalabilit√© et la maintenabilit√©.*
